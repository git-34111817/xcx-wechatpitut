list索引是从后往前执行的.

c的结尾用的NULL,python中用None表示空.
python类使用自己内部刚建立的函数要加self.
注意时间复杂度

枚举，输入，输出，有穷性，确定性，可行性


#cur指的是指向指针
#prev指的是指向指针
#next下一个
#item指的存放的数据
#pos指的是位置 往往和item合并做参数传递title

枚举，输入，输出，有穷性，确定性，可行性
时间复杂度：都用一个统一的表示
大O表示法：一类型的特征。
最坏时间复杂度：最长时间
最优时间复杂度：最短时间
平均时间复杂度：平均需要多长时间。
通常说的时间复杂度指的就是最坏时间复杂度。

基本操作都算1。
	顺序采用加法进行运算。
	循环用乘法。
	分支结构，时间复杂度取最大值。
	判断一个算法效率，往往只关注数量的最高次项，其他次项和常数项都可以忽略。
	在没特殊要求情况下，时间复杂度都是指最坏时间复杂度，
算法时间度排名：O(1)<O(logn)<O(nlogn)<O(n^2)<O(2^n)<O(n!)<O(n^n)

顺序表分为链表和顺序表
顺序表刚开始就都得定好容量
顺序表：指的是同一种类型按照连续的内存形成规律性的访问存储的表。
顺序表的两种形式：顺序表的基本布局、元素外置的顺序表。
顺序表 = 表头信息（容量、元素个数） + 数据区。
构造方式：
	编译器构造。（一体式当存储不够就会重新申请空间拷贝）
	手动构造：表头加申请内存空间。只加了一个指向地址，使得表头不用变只把下面的拷贝就完成了。
两种扩充的方式：
	每次加多10个位置预留。操作多会卡顿。
	每次翻倍的增加位置预留。操作少不卡顿但会浪费空间资源。
保证大小顺序不改变。
索引indexx[]
赋值 index assignment
最尾增加 append
最尾删除 pop()
指定位置删除pop(i)
指定位置增加insert(i,iten)
删除del operator
迭代iteration
包含contains
切片get slice[x:y]
删除del slice
set slice
reverse
concatenate
sort
multiply

链表和顺序表都是线性的。
链表就是将元素存放在通过连接构造起来的一系列存储块中。
堆栈说的事操作。
压栈：
	stack（）创建一个空栈
	push（item）添加一个新的元素到itenm到栈顶
	pop()弹出栈顶元素
	peek（）返回栈顶元素
	is_empty()判断栈是否为空。
	size（）返回栈的元素个数

c的结尾用的NULL,python中用None表示空.

链表中用直接判断下一个是否是None来判断.不要加next容易麻烦还处错误.
后继节点:就是后面的那个节点.

特性决定效率,不改算法一切百搭.

顺序表和链表的时间复杂度对比:
操作          链表       顺序表
访问元素      O(n)       O(1)
在头部插入删除O(1)       O(n)
在尾部插入删除O(n)       O(1)
在中间插入删除O(n)       O(n)

单项循环链表:

